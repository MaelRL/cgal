namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_HeatMethod
\cgalAutoToc
\author Keenan Crane, Christina Vaz, Andreas Fabri

The <em>Heat Method</em> is an algorithm that solves the multiple-source
shortest path problem by returning the geodesic distance from the points in the
domain to the closest point in the source set.  The Heat
Method is more efficient and more robust than previous distance
computations, as the algorithm boils down to two standard, numerical
linear algebra problems.



In Section \ref sec_HM_definitions we present the mathematical background. In
Section \ref sec_HM_history we explain the design of the algorithm and
traits.

Note that this package requires the third party \ref thirdpartyEigen library.
This implementation is based on \cgalCite{cgal:cww-ghnac-13} and \cgalCite{cgal:fsbs-acidt-06}


The Heat Method nees



\section sec_HM_examples Examples

We give examples for the free function, for the `Heat_method_3` class and
for the  `Intrinsic_Delaunay_triangulation_3`class. 

\subsection HM_example_Free_function Using a Free Function

The first example calls a free function that computes the distance to a single source vertex.
The distances are written into a `std::map`.

\cgalExample{Heat_method_3/heat_method.cpp}

\subsection HM_example_Class Using the Heat Method Class

The following example shows the heat method class. It can be used
when one adds and removes source vertices. It precomputes matrices
which depend only on the mesh and not the set of source vertices
only once.

\cgalExample{Heat_method_3/heat_method_surface_mesh.cpp}


\subsection HM_example_Intrinsic Using the Intrinsic Delaunay Triangulation

The following example shows the heat method on a triangle mesh using
the intrinsic Delaunay triangulation algorithm. This should be done when the
triangles are very .....................

\cgalExample{Heat_method_3/heat_method_surface_mesh_intrinsic.cpp}



\section sec_HM_definitions Theoretical Background

Section \ref Subsection_HM_Definitions_Intro gives an overview of the theory needed by the heat method.
Section \ref Subsection_HM_IDT_Definitions gives the background needed for the Intrinsic Delaunay Triangulation.

\subsection Subsection_HM_Definitions_Intro The Heat Method Algorithm

For a detailed overview of the heat method, the reader may consult
\cgalCite{cgal:cww-ghnac-13} to read the original article. In the
sequel, we introduce the basic notions so as to explain our
algorithms. In general, the heat method is applicable to any setting
if there exists a gradient operator \f$ \nabla\f$, a divergence
operator \f$\nabla\f$ and a Laplace operator \f$\Delta = \nabla \cdot
\nabla\f$ which are standard derivatives from vector calculus.

The Heat Method consists of three main steps:
   Algorithm:
           -# Integrate the heat flow \f$ \dot u = \Delta u\f$ for some fixed time \f$t\f$.
           -# Evaluate the vector field   \f$ X = -\nabla u_t / |\nabla u_t| \f$.
           -# Solve the Poisson Equation \f$ \Delta \phi = \nabla \cdot X \f$.


The function \f$ \phi \f$ is an approximation of the distance to the given source set and approaches the true distance as t goes to zero.
The algorithm must then be translated in to a discrete algorithm by replacing the derivatives in space and time with approximations.

The heat equation can be discretized in time using a single backward Euler step. This means the following equation must be solved:

\f$(id-t\Delta)u_t = \delta(x) \f$ where \f$\delta(x)\f$ is a Dirac delta encoding an 'infinite' spike of heat (1 if x is in the source set, 0 otherwise)
        over the entire domain M, where id is the identity operator.

The heat equation is discretized in space depending on the
structure. For this package, we use triangle meshes exclusively.
Let \f$ u \in \R^{|V|}\f$ specify a piecewise linear function on a
triangulated surface with vertices \f$V\f$, edges \f$E\f$ and faces
\f$F\f$.  A standard discretization of the Laplacian at vertex \f$i\f$
is:

\f$ {Lu}_i = \frac{1}{2A_i} \sum_{j}(cot \alpha_{ij} + cot \beta_{ij})(u_j-u_i)\f$ where \f$A_i\f$ is one third the area of all triangles incident on vertex \f$i\f$.

The sum is taken over all of the neighboring vertices
\f$j\f$. Further, \f$\alpha_{ij}\f$ and \f$\beta_{ij}\f$ are the
angles opposing the corresponding edge \f$ij\f$. We express this
operation via a matrix \f$L = M^{-1}L_c\f$ where \f$M \in
R^{|V|x|V|}\f$ is a diagonal matrix containing the vertex areas and
\f$L_c \in R^{|V|x|V|} \f$ is the cotan operator representing the
remaining sum.

From this, the symmetric positive-definite system
\f$(M-tL_C)u = \delta_{\gamma}\f$ can be solved to find
\f$u\f$ where \f$\delta_{\gamma}\f$ is the Kronecker delta over \f$\gamma\f$.

Next, the gradient in a given triangle can be expressed as:

\f$\nabla \cdot X = \frac{1}{2} \sum_j cot\theta_1 (e_1 \cdot X_j) + cot \theta_2 (e_2 \cdot X_j)\f$

where the sum is taken over incident triangles \f$j\f$ each with a vector \f$X_j\f$,
\f$e_1\f$ and \f$e_2\f$ are the two edge vectors of triangle \f$j\f$
containing \f$i\f$ and \f$\theta_1\f$, \f$\theta_2\f$ are the opposing angles.

Finally, let \f$b \in R^{|V|}\f$ be the integrated divergences of the normalized vector field X.
Thus, solving the symmetric Poisson problem \f$ L_c \phi = b\f$ computes the final distance function.

\subsection Subsection_HM_IDT_Definitions Intrinsic Delaunay Triangulation

The standard discretization of the cotan Laplace operator uses the cotangents of the angles in the triangle mesh.
The intrinsic Delaunay triangulation is used to address extreme angles in the mesh.
    - An edge of a mesh is locally Delaunay if the sum of the cotangents of the opposing angles is greater than or equal to 0. A mesh is Delaunay if all of its edges are locally Delaunay.

A standard algorithm to convert a given planar triangulation into a Delaunay triangulation is
to flip non-Delaunay edges in a mesh until the mesh is Delaunay.
Similarly, the intrinsic Delaunay triangulation of a simplicial \f$R^3\f$ surface
is constructed by performing intrinsic edge flips.

  - An intrinsic property is a byproduct of only the topology of the mesh.
  That is, the property does not change if the way the mesh is represented changes.
  For example, edge lengths and angles are intrinsic whereas vertex coordinates and orientation are extrinsic.

The intrinsic Delaunay triangulation thus relies on edge lengths and angles,
as does the Heat method. The intrinsic Delaunay triangulation does not actually flip the edge.
Instead, the edge flips are intrinsic and so the shape of the original embedded mesh does not change.
Instead, the IDT mesh is considered as an abstract surface with a locally Euclidean metric.
Instead of actually flipping an edge, the algorithm performs a combinatorial flip on it and updates its length.
Thus, there is no change to the intrinsic geometry of the input mesh.
  
Let \f$ K = (V,E,T) \f$ be a 2-manifold triangle mesh, where \f$V\f$ is the vertex set,
\f$ E \f$ is the edge set and \f$ T \f$ is the face set (triangle set).
Let \f$ L \f$ be the set of Euclidean distances, where \f$ L(e_{ij}) = l_{ij} = || p_i - p_j || \f$ ,
where \f$ p_i \f$ and \f$ p_j \f$ are the point positions \f$ \in R^3 \f$ of vertices \f$ i \f$ and \f$ j \f$ respectively.
Then, let the pair \f$ (K,L) \f$ be the input to the iDT algorithm which returns the pair \f$(\tilde K, \tilde L)\f$,
which are the intrinsic Delaunay mesh and the intrinsic lengths.
The algorithm is as follows:

            \code
             for all edge e in E : Mark(e)
             Stack s <-- E
             while !Empty(s) do
               edge(ij) = Pop(s) and Unmark(edge(ij))
                if !Delaunay(edge(ij)) then
                  edge(kl) = Flip(edge(ij)) and compute the new length length(kl) using the Cosine Theorem
                   for all edge e in {edge(kj), edge(jl), edge(li), edge(ik)} do
                     if !Mark(e) then
                       Mark(e) and Push(s,e)
                     end if
                  end for
                end if
              end while
            return (~K,~L)
            \endcode


  The new \f$(\tilde K, \tilde L)\f$ are then used in the Heat Method distance computation.


  The following figures demonstrate the difference between the heat method with and without intrinsic Delaunay remeshing.
  \cgalFigureBegin{landscape_mesh, landscape2withoutidt.png}
    Isolines placed on a mesh without iDT remeshing
  \cgalFigureEnd
  \cgalFigureBegin{landscape_mesh_idt, landscape2withidt.png}
    Isolines placed on a mesh with iDT remeshing
  \cgalFigureEnd
  \cgalFigureBegin{circle_box, red_circle_box_without_idt_bottom.png}
    Isolines placed on a mesh without iDT remeshing
  \cgalFigureEnd
  \cgalFigureBegin{circle_box_idt, red_circle_box_with_idt_bottom.png}
    Isolines placed on a mesh with iDT remeshing
  \cgalFigureEnd




\section sec_HM_history Implementation History

This package was developed by Christina Vaz, Keenan Crane and Andreas
Fabri as a project of the Google Summer of Code 2018. 



*/
} /* namespace CGAL */

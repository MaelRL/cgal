\begin{ccRefClass}{Triangulation<TriangulationTraits, TriangulationDataStructure>}

\ccDefinition

The class \ccRefName\ is used to store and query the full cells and vertices of
a triangulationin dimension $d$. A special vertex, named
{em infinite vertex}, is used to triangulate the  outside of the convex
hull of the points in so called {\em infinite cells}.

\ccInclude{CGAL/Triangulation.h}

\ccParameters

\ccc{TriangulationTraits} is the geometric traits class that provides the geometric types
and predicates needed by triangulations. \ccc{TriangulationTraits} must be a model of the
concept \ccc{TriangulationTraits}.

\ccc{TriangulationDataStructure} is the class used to store the underlying triangulation data
structure. \ccc{TriangulationDataStructure} must be a model of the concept
\ccc{TriangulationDataStructure}. The class template \ccRefName\ can
be defined  by specifying only the first parameter, or by using the
tag \ccc{CGAL::Default} as
the second parameter. In both cases, \ccc{TriangulationDataStructure} defaults to
\ccc{Triangulation_data_structure<Maximal_dimension<TriangulationTraits::Point_d>::type,
Triangulation_vertex<TriangulationTraits>, Triangulation_full_cell<TriangulationTraits>>}.

\ccTypes
\ccThree{typedef  TriangulationTraits::Point_d}{Maximal_dimension;}{}
%The following types are self-explanatory: % but we are explaining anyway

\ccTypedef{typedef TriangulationTraits Geom_traits;}%
{Type for the model of the \ccc{TriangulationTraits} concept.}

\ccTypedef{typedef  TriangulationTraits::Point_d Point;}{A point in Euclidean space.}

\ccTypedef{typedef TriangulationTraits::Dimension  Maximal_dimension;}%
{This indicates whether the dimension of the underlying space is static
(\ccc{Maximal_dimension}=\ccGlobalScope\ccc{Dimension_tag<int dim>}) or
dynamic (\ccc{Maximal_dimension}=\ccGlobalScope\ccc{Dynamic_dimension_tag}).
In the latter case, the \ccc{dim} parameter passed to the class's constructor
is used.}

\ccTypedef{typedef TriangulationDataStructure Triangulation_ds;}%
{The second template parameter.}


\ccThree{typedef  TriangulationDataStructure::Full_cell_iterator}{Full_cell_iterator}{}


\ccTypedef{typedef TriangulationDataStructure::Vertex Vertex;}{A model of the concept
\ccc{TriangulationVertex}.}
\ccGlue
\ccTypedef{typedef TriangulationDataStructure::Full_cell Full_cell;}{A model of the concept
\ccc{TriangulationFullCell}.}
\ccGlue
\ccTypedef{typedef TriangulationDataStructure::Facet Facet;}{The facet
class}
\ccGlue
\ccTypedef{typedef TriangulationDataStructure::Face Face;}%
{A model of the concept \ccc{TriangulationDSFace}.}

The vertices and full cells of triangulations are accessed through handles,
iterators and circulators. A handle is a model of the \ccc{Handle} concept,
and supports the two dereference operators \ccc{operator*} and
\ccc{operator->}. A circulator is a model of the concept \ccc{Circulator}.
Iterators and circulators are bidirectional and non-mutable.

Iterators and circulators are convertible to the corresponding handles, thus
the user can pass them directly as arguments to the functions.

\ccTypedef{typedef  TriangulationDataStructure::Vertex_handle
  Vertex_handle;}{handle to a a vertex}
\ccGlue\ccTypedef{typedef  TriangulationDataStructure::Vertex_iterator
  Vertex_iterator;}{iterator over all vertices}

\ccTypedef{typedef  TriangulationDataStructure::Full_cell_handle
  Full_cell_handle;}{handle to a full cell}
\ccGlue\ccTypedef{typedef
  TriangulationDataStructure::Full_cell_iterator
  Full_cell_iterator;}{iterator over all full cells}

\ccTypedef{typedef  TriangulationDataStructure::Facet_iterator
  Facet_iterator;}{iterator over all facets}

\ccTypedef{typedef TriangulationDataStructure::size_type size_type;}{Size type (an unsigned integral
type).}
\ccGlue\ccTypedef{typedef TriangulationDataStructure::difference_type difference_type;}{Difference
type (a signed integral type).}

The \ccRefName\ class also defines the following enum type to specify
which case occurs when locating a point in the triangulation:

\ccEnum{
enum  Locate_type
{
      ON_VERTEX
    , IN_FACE
    , IN_FACET
    , IN_FULL_CELL
    , OUTSIDE_CONVEX_HULL
    , OUTSIDE_AFFINE_HULL
};}{See \ccc{CGAL::Triangulation::Locate_type}}

\ccCreation
\ccCreationVariable{tr}

\ccConstructor{Triangulation(const int dim, const Geom_traits & gt =
Geom_traits())}
{Instantiates a triangulation with one vertex (the vertex at infinity). See the
description of the nested type \ccc{Maximal_dimension} above for an
explanation of the use of the parameter \ccc{dim}. The triangulation stores a copy
of the geometric traits \ccc{gt}.}

\ccConstructor{Triangulation(const Triangulation & t2);}
{The copy constructor.}% All vertices and full cells are duplicated.}

\ccHeading{Access functions}

\ccThree{Finite_full_cell_iterator}{tr.number_of_vertices() const}{}

\ccMethod{const Triangulation_ds & tds() const;}%
{Returns a const reference to the underlying triangulation data structure.}

\begin{ccAdvanced}
\ccMethod{Triangulation_ds & tds();}%
{Returns a non-const 
reference to the underlying triangulation data structure.}
\end{ccAdvanced}

\ccMethod{const Geom_traits & geom_traits() const;}%
{Returns a const reference to the geometric traits instance.}

\ccMethod{int maximal_dimension() const;}%
{Returns the dimension of the embedding Euclidean space.}
\ccGlue
\ccMethod{int current_dimension() const;}%
{Returns the dimension of the triangulation (as an embedded manifold).}

\ccMethod{bool empty() const;}%
{Returns \ccc{true} if the triangulation has no finite vertex. Returns
\ccc{false} otherwise.}
\ccGlue
\ccMethod{size_type number_of_vertices() const;}%
{Returns the number of finite vertices in the triangulation.}
\ccGlue
\ccMethod{size_type number_of_full_cells() const;}%
{Returns the number of full cells of maximal dimension in the triangulation
(full cells incident to the vertex at infinity are counted).}

\ccMethod{Vertex_handle infinite_vertex() const;}%
{Returns a handle to the vertex at infinity.}

\ccMethod{Full_cell_handle infinite_full_cell() const;}%
{Returns a handle to some full cell incident to the vertex at infinity.}

\ccHeading{Non-constant-time access functions}

\ccMethod{size_type number_of_finite_full_cells() const;}%
{Returns the number of full cells of maximal dimension that are not
  incident to the vertex at infinity.}

\ccHeading{Tests for finite and infinite elements}

\ccMethod{bool is_infinite(const Vertex_handle v) const;}
{Returns \ccc{true} if and only if the vertex \ccc{v} is the infinite vertex.}

\ccGlue

\ccMethod{bool is_infinite(const Full_cell_handle c) const;}
{Returns \ccc{true} if and only if \ccc{c} is incident to the infinite vertex.
%\ccPrecond $0\leq$\ccVar.\ccc{current_dimension()}.
}

\ccGlue

\ccMethod{bool is_infinite(const Facet & ft) const;}
{Returns \ccc{true} if and only if facet \ccc{ft} is incident to the infinite
vertex. 
}

\ccGlue

\ccMethod{bool is_infinite(const Face & f) const;}{Returns \ccc{true} if and
only if the face \ccc{f} is incident to the infinite vertex. 
}


%\ccHeading{Queries}

% \ccMethod{bool is_vertex(const Point & p, Vertex_handle & v) const;} {Tests
% whether \ccc{p} is a vertex of \ccVar\ by locating \ccc{p} in the triangulation.  If
% \ccc{p} is found, the associated vertex \ccc{v} is given.}

% \ccGlue\ccMethod{bool is_vertex(const Point & p, Vertex_handle & v,
% Full_cell_handle hint) const;} {Same as above.  The \ccc{Full_cell_handle hint} is
% an optional parameter that is used as a hint for the point location.}

% \ccGlue\ccMethod{bool is_vertex(Vertex_handle v) const;}
% {Tests whether \ccc{v} is a vertex of \ccVar.}

% \ccMethod{bool is_full_cell(Full_cell_handle c) const;}
% {Tests whether \ccc{c} is a full cell of \ccVar.}

% \ccMethod{Orientation orientation(Full_cell_handle c) const;}
% {Returns the orientation of the finite full cell \ccc{c}:
% \ccGlobalScope\ccc{POSITIVE}, \ccGlobalScope\ccc{NEGATIVE} or
% \ccGlobalScope\ccc{COPLANAR}. If \ccVar.\ccc{current_dimension() == 0}, then
% \ccGlobalScope\ccc{POSITIVE} is returned. Under normal circumstances, the function
% should always return \ccGlobalScope\ccc{POSITIVE}.
% \ccPrecond Full cell \ccc{c} must be finite.
% }

% \ccMethod{template< typename OutputIterator > OutputIterator
% incident_full_cells(Vertex_const_handle v, OutputIterator out) const;}
% {Insert in \ccc{out} all the full cells that are incident to the vertex
% \ccc{v}, {i.e.}, the full cells that have the \ccc{Vertex v} as a vertex.
% Returns the (modified) output iterator.
% %\ccPrecond\ccc{is_full_cell(f.full_cell())}.
% }

% \ccMethod{template< typename OutputIterator > OutputIterator
% incident_full_cells(const Face & f, OutputIterator out) const;}
% {Insert in \ccc{out} all the full cells that are incident to the face \ccc{f},
% {i.e.}, the full cells that have the \ccc{Face f} as a subface.
% Returns the output iterator.
% %\ccPrecond\ccc{is_full_cell(f.full_cell())}.
% }

% \ccMethod{template< typename OutputIterator > OutputIterator
% star(const Face & f, OutputIterator out) const;}
% {Insert in \ccc{out} all the full cells that share at least one vertex with the \ccc{Face
% f}. Returns the output iterator.
% %\ccPrecond\ccc{is_full_cell(f.full_cell())}.
% }

% \ccMethod{template< typename OutputIterator > OutputIterator
% incident_faces(Vertex_handle v, const int d, OutputIterator
% out);}{Constructs all the \ccc{Face}s of dimension \ccc{d} incident to
% \ccc{Vertex} v and inserts them in the \ccc{OutputIterator out}. If
% $d\geq$  \ccVar.\ccc{current_dimension()}, then no \ccc{Face} is
% constructed.
% \ccPrecond$0 < d$.
% }

% \ccMethod{template< typename OutputIterator > OutputIterator
% incident_upper_faces(Vertex_const_handle v, int d, OutputIterator
% out);}{Constructs all the {\em upper} \ccc{Face}s of dimension \ccc{d}
% incident to \ccc{Vertex} v and inserts them in the \ccc{OutputIterator out}.\\
% Assuming some total ordering on the vertices of the triangulation (which is
% invariant as long as no vertex is inserted in or removed from the triangulation), a
% \ccc{Face} incident to \ccc{v} is an {\em upper} \ccc{Face} if and only if
% its vertices occur at \ccc{v} or beyond \ccc{v} in the ordering.\\ In
% particular, taking the disjoint union of the upper \ccc{Face}s of dimension
% \ccc{d} incident to every vertex of the triangulation yields exactly the set of
% faces of dimension \ccc{d} of the triangulation.\\ The constructed \ccc{Faces} are
% lexicographically ordered using the vertex order as base ordering. In order to
% make it easy to find the infinite \ccc{Faces}, the latter ordering makes the
% vertex at infinity the smallest vertex; so calling the method on a finite
% vertex will construct only finite faces and calling it on the vertex at
% infinity will produce all infinite \ccc{d}-faces. (Elle est pas belle, la vie
% ?) If $d\geq $\ccVar.\ccc{current_dimension()}, then no \ccc{Face} is
% constructed.
% \ccPrecond$0 < d$.
% }

% \ccGlue\ccMethod{template< typename OutputIterator, typename Comparator >
% OutputIterator incident_upper_faces(Vertex_const_handle v, const int d,
% OutputIterator out, Comparator cmp);} {Same as above, but uses \ccc{cmp} as
% the vertex ordering to define the upper faces.}

\ccHeading{Faces and Facets} % - - - - - - - - - - - - - - - - - - - - FACETS

\ccMethod{Full_cell_handle full_cell(const Facet & f) const;}
{Returns a full cell containing the facet \ccc{f}}

\ccMethod{int index_of_covertex(const Facet & f) const;}
{Returns the index of the vertex of the full cell
\ccc{c=}\ccVar.\ccc{full_cell(f)} which does {not} belong to \ccc{c}.}

\ccHeading{Triangulation traversal} % - - - - - - - - - - - - - - - - - - TRAVERSAL

%\ccMethod{Vertex_const_iterator vertices_begin() const;}{}
%\ccGlue
\ccMethod{Vertex_iterator vertices_begin();}
{The first vertex of \ccVar.}
%\ccGlue\ccMethod{Vertex_const_iterator vertices_end() const;}{}
\ccGlue\ccMethod{Vertex_iterator vertices_end();}
{The beyond vertex of \ccVar.}

%\ccMethod{Finite_vertex_const_iterator finite_vertices_begin() const;}{}
%\ccGlue
\ccMethod{Finite_vertex_iterator finite_vertices_begin();}
{The first finite vertex of \ccVar.}
%\ccGlue\ccMethod{Finite_vertex_const_iterator finite_vertices_end() const;}{}
\ccGlue\ccMethod{Finite_vertex_iterator finite_vertices_end();}
{The beyond finite vertex of \ccVar.}

%\ccMethod{Full_cell_const_iterator full_cells_begin()const;}{}\ccGlue
\ccMethod{Full_cell_iterator full_cells_begin();}
{The first full cell of \ccVar.}
%\ccGlue\ccMethod{Full_cell_const_iterator full_cells_end() const;}{}
\ccGlue\ccMethod{Full_cell_iterator full_cells_end();}
{The beyond full cell of \ccVar.}

%\ccMethod{Finite_full_cell_const_iterator finite_full_cells_begin()  const;}{}\ccGlue
\ccMethod{Finite_full_cell_iterator finite_full_cells_begin();}
{The first finite full cell of \ccVar.}
%\ccGlue\ccMethod{Finite_full_cell_const_iterator finite_full_cells_end() const;}{}
\ccGlue\ccMethod{Finite_full_cell_iterator finite_full_cells_end();}
{The beyond finite full cell of \ccVar.}

\ccMethod{Facet_iterator facets_begin();}
{Iterator to the first facet of the triangulation.}
\ccGlue
\ccMethod{Facet_iterator facets_end();}
{Iterator to the beyond facet of the triangulation.}

\ccMethod{Finite_facet_iterator finite_facets_begin();}
{Iterator to the first finite facet of the triangulation.}
\ccGlue
\ccMethod{Finite_facet_iterator finite_facets_end();}
{Iterator to the beyond finite facet of the triangulation.}

\ccHeading{Point location} % - - - - - - - - - - - - - - - - - POINT LOCATION

The class \ccRefName\ provides methods to locate a query point with respect to
the triangulation:

\ccMethod{Full_cell_handle locate(const Point & query,
Full_cell_handle hint = Full_cell_handle()) const;}
{The optional argument \ccc{hint} is used as a starting place for the search.\\
If the \ccc{query} point lies outside the affine hull of the points (which can
happen when \ccVar.\ccc{current_dimension() < }
\ccVar.\ccc{maximal_dimension()}) or if there is no finite vertex yet in the
triangulation, then \textit{locate} returns a default constructed
\ccc{Full_cell_handle()}.\\
If the point \ccc{query} lies in the interior of a bounded (finite) full cell of \ccVar,
the latter full cell is returned.\\
If \ccc{query} lies on the boundary of some finite full cells, one of them
is returned.\\
Let $d=$\ccVar.\ccc{current_dimension()}. If the point \ccc{query} lies
outside the convex hull of the points, an infinite full cell with vertices $\{
p_1, p_2, \ldots, p_d, \infty\}$ is returned such that the full cell $(p_1, p_2,
\ldots, p_d, query)$ is positively oriented (the rest of the triangulation lies
on the other side of facet $(p_1, p_2, \ldots, p_d)$).}

\ccMethod{Full_cell_handle locate(const Point & query, Vertex_handle hint)
const;}
{Same as above but \ccc{hint} is a vertex and not a full cell.}

\ccMethod{Full_cell_handle locate(const Point & query, Locate_type & loc_type,
Face & f, Facet & ft, Full_cell_handle hint = Full_cell_handle()) const;}
{The optional argument \ccc{hint} is used as a starting place for the
search.\\ If the \ccc{query} point lies outside the affine hull of the points
(which can happen when \ccVar.\ccc{current_dimension() < }
\ccVar.\ccc{maximal_dimension()}) or if there is no finite vertex yet in the
triangulation, then \ccc{loc_type} is set to
\ccc{OUTSIDE_AFFINE_HULL}, and \textit{locate} returns
\ccc{Full_cell_handle()}.\\ If the \ccc{query} point lies inside the affine hull
of the points, a $k$-face that contains \ccc{query} {in its relative
interior} is returned. (If the $k$-face is finite, it is
unique.)\begin{itemize} \item[$k=0$] \ccc{loc_type} is set to \ccc{ON_VERTEX},
\ccc{f} is set to the vertex \ccc{v} the \ccc{query} lies on and a full cell
having \ccc{v} as a vertex is returned.
\item[$0<k<$\ccc{c.current_dimension()-1}] \ccc{loc_type} is set to
\ccc{IN_FACE}, \ccc{f} is set to the unique finite face containing the
\ccc{query} point. A full cell having \ccc{f} on its boundary is returned.
\item[$k=$\ccc{c.current_dimension()-1}] \ccc{loc_type} is set to
\ccc{IN_FACET}, \ccc{ft} is set to one of the two representation of
the finite facet containing the
\ccc{query} point. The full cell of \ccc{ft} is returned.
\item[$k=$\ccc{c.current_dimension()}] If the \ccc{query} point lies
{\em outside} the convex hull of the points in the triangulation, then
\ccc{loc_type} is set to \ccc{OUTSIDE_CONVEX_HULL} and a full cell is returned
as in the \ccc{locate} method above. If the \ccc{query} point lies
{\em inside} the convex hull of the points in the triangulation, then
\ccc{loc_type} is set to \ccc{IN_FULL_CELL} and the unique full cell containing
the \ccc{query} point is returned. \end{itemize}}

\ccMethod{Full_cell_handle
          locate(const Point & query, Locate_type & loc_type,
                 Face & f, Vertex_handle hint) const;}
{Same as above but \ccc{hint}, the starting place for the search, is a vertex.
The parameter \ccc{hint} is ignored if it is a default constructed
\ccc{Vertex_handle()}.}

\ccHeading{Removal} % - - - - - - - - - - - - - - - - - - - - - - - REMOVALS

\begin{ccAdvanced}

\ccMethod{Vertex_handle collapse_face(const Point & p, const Face & f);}
{Contracts the \ccc{Face f} to a single vertex at position \ccc{p}. Returns a
handle to that vertex. 
\ccPrecond The boundary of the union of full cells incident to \ccc{f} must
 be a triangulation of a sphere of dimension
\ccVar.\ccc{current_dimension()}).
}

\end{ccAdvanced}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - INSERTION

\ccHeading{Point insertion}

The class \ccRefName\ provides functions to insert a given point in the
triangulation:

\ccMethod{template< typename ForwardIterator >
size_type insert(ForwardIterator s, ForwardIterator e);}%
{Inserts the points found in range \ccc{[s,e)} in the triangulation. Returns
the number of vertices actually inserted. (If several vertices share the
same position in space, only the first insertion is counted.)}

\ccMethod{Vertex_handle insert(const Point p, Full_cell_handle hint =
Full_cell_handle());}{Inserts point \ccc{p} in the triangulation.  Returns a
\ccc{Vertex_handle} to the vertex of the triangulation with position \ccc{p}.
Prior to the actual insertion, \ccc{p} is located in the triangulation;
\ccc{hint} is used as a starting place  for locating \ccc{p}.}

\ccMethod{Vertex_handle insert(const Point  p, Vertex_handle hint);}%
{Same as above but uses a vertex \ccc{hint} as the starting place for the search.}

\begin{ccAdvanced}

\ccMethod{Vertex_handle insert(const Point  p, Locate_type
loc_type, Face & f, Facet & ft, Full_cell_handle c);} {Inserts
point \ccc{p} into the triangulation and returns a handle to the
\ccc{Vertex} at that position. The action taken depends on the value of
\ccc{loc_type}:\begin{itemize} \item[\ccc{ON_VERTEX}] The point of the
\ccc{Vertex} described by \ccc{f} is set to \ccc{p}. \item[\ccc{IN_FACE}]
The point \ccc{p} is inserted in the \ccc{Face f}. \item[\ccc{IN_FACET}]
The point \ccc{p} is inserted in the \ccc{Facet ft}. \item[Anything else]
The point \ccc{p} is inserted in the triangulation according to the value
of \ccc{loc_type}, using the full cell \ccc{c}.\end{itemize} This method is used
internally by the other \ccc{insert()} methods.}

\ccMethod{template < typename ForwardIterator, typename OutputIterator >
Vertex_handle insert_in_hole(const Point & p, ForwardIterator s,
ForwardIterator e, const Facet & ft, OutputIterator out);}{The full cells in
the range $C=$\ccc{[s, e)} are removed, thus forming a hole. A \ccc{Vertex} is
inserted at position \ccc{p} and connected to the boundary of the hole in
order to ``fill it''. A \ccc{Vertex_handle} to the new \ccc{Vertex} is
returned. The facet \ccc{ft} must lie on the boundary of $C$ and its
defining full cell, \ccVar.\ccc{full_cell(ft)} must lie inside $C$. Handles
to the newly created full cells are output in the \ccc{out} output iterator.
\ccPrecond $C$ must be a (geometric) ball, must contain \ccc{p} in its
interior and not contain any vertex all of whose incident full cells are in
$C$. (This implies that \ccVar.\ccc{current_dimension()}$\geq2$ if
$|C|>1$.) The boundary of $C$ must be a triangulation of the sphere
$\sphere^{k-1}$.}

\ccMethod{template < typename ForwardIterator > Vertex_handle
insert_in_hole(const Point & p, ForwardIterator s, ForwardIterator e, const
Facet & ft);}{Same as above, but the newly created full cells are not
retrieved.}

\ccMethod{Vertex_handle insert_in_face(const Point & p, const Face & f);}%
{Inserts point \ccc{p} in the triangulation.
\ccPrecond \ccc{p} must lie in the relative interior of \ccc{f}.}

\ccMethod{Vertex_handle insert_in_facet(const Point & p, const Facet & ft);}%
{Inserts point \ccc{p} in the triangulation.
\ccPrecond \ccc{p} must lie in the relative interior of \ccc{ft}.}

\ccMethod{Vertex_handle insert_in_full_cell(const Point & p, Full_cell_handle
c);}%
{Inserts point \ccc{p} in the triangulation. \ccPrecond \ccc{p} must lie in the
interior of \ccc{c}.}

\ccMethod{Vertex_handle insert_outside_convex_hull(const Point &,
        Full_cell_handle c);}%
{Inserts point \ccc{p} in the triangulation.
\ccPrecond \ccc{p} must lie outside the convex hull of \ccVar. The half-space
defined by the infinite full cell \ccc{c} must contain \ccc{p}.}

\ccMethod{Vertex_handle insert_outside_affine_hull(const Point &);}%
{Inserts point \ccc{p} in the triangulation.
\ccPrecond \ccc{p} must lie outside the {affine} hull of \ccVar.}

\end{ccAdvanced}


\begin{ccDebug}
  \ccHeading{Validity check}

\ccMethod{bool is_valid(bool verbose=false) const;}
{Partially checks whether \ccVar\ is a triangulation. This function returns
\ccc{true} if the combinatorial triangulation data structure's \ccc{is_valid()}
test returns \ccc{true} and if some geometric tests are passed with success: It
is checked that the orientation of each finite full cell is positive and that
the orientation of each infinite full cell is consistent with their finite
adjacent full cells.
The \ccc{verbose} parameter is not used.%
}

\ccMethod{bool are_incident_full_cells_valid(Vertex_const_handle v, bool
verbose = false) const;} {Returns \ccc{true} if and only if all
finite full cells incident to \ccc{v} have positive orientation.
The \ccc{verbose} parameter is not used.%
}

\end{ccDebug}

\ccHeading{Input/Output}

\ccFunction{istream & operator>> (istream & is, Triangulation & t);}
{Reads the underlying combinatorial triangulation from \ccc{is} by
calling the corresponding input operator of the triangulation data
structure class (note that the infinite vertex is numbered 0), and the
non-combinatorial information by calling the corresponding input
operators of the vertex and the full cell classes (such as point
coordinates), which are provided by overloading the stream operators
of the vertex and full cell types. Assigns the resulting triangulation to
\ccc{t}.}

\ccFunction{ostream& operator<< (ostream& os, const Triangulation & t);}
{Writes the triangulation \ccc{t} into \ccc{os}.}

The information in the \ccc{iostream} is: the current dimension, the number of
finite vertices, the non-combinatorial information about vertices (point,
\emph{etc.}), the number of full cells, the indices of the vertices of each
full cell, plus the non-combinatorial information about each full cell, then the
indices of the neighbors of each full cell, where the index corresponds to the
preceding list of full cells.

\ccSeeAlso

\ccc{Triangulation_data_structure<Dimensionality, TriangulationDSVertex, TriangulationDSFullCell>},\\
\ccc{Delaunay_triangulation<DelaunayTriangulationTraits, TriangulationDataStructure>},\\
%\ccc{Regular_triangulation<RTTraits, TriangulationDataStructure>}.

\end{ccRefClass}


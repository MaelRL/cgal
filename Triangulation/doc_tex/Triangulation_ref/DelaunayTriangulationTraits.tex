
\begin{ccRefConcept}{DelaunayTriangulationTraits}

\ccDefinition

The concept \ccRefName\ describes the various types and functions that a class
has to provide as the first parameter (\ccc{DCTraits}) to the class template
\ccc{Delaunay_triangulation<DelaunayTriangulationTraits, TriangulationDataStructure>}. It brings the geometric ingredients to
the definition of a Delaunay complex, while the combinatorial
ingredients are
brought by the second template parameter, \ccc{TriangulationDataStructure}.

\ccRefines

\ccc{TriangulationTraits}.

\ccTypes

\ccTwo{DelaunayTriangulationTraits ::}{}

%\ccNestedType{Point_d}{This nested type is defined in the ``parent'' concept
%\ccc{TriangulationTraits}.}

\ccNestedType{Side_of_oriented_sphere_d}{A predicate object that must provide
the templated operator\\\ccc{template<typename ForwardIterator> Oriented_side
operator()(ForwardIterator start, ForwardIterator end, const Point_d &
p)}.\\The operator returns \ccc{ON_POSITIVE_SIDE},
\ccc{ON_NEGATIVE_SIDE} 
or \ccc{ON_ORIENTED_BOUNDARY}  depending of the side of the query
point \ccc{p}
 with respect to the sphere circumscribing the simplex
defined by the points in range \ccc{[start,end)}. 
If the simplex is positively
oriented, then the positive side of sphere corresponds geometrically
to its bounded side.
%\\ The range's size must of course be one more
%than the dimension of the Euclidean space the points live in: 
\ccPrecond
 \ccc{std::distance(start,end)=D+1}, where 
\ccc{Point_dimension_d(*it)} is $D$ for all \ccc{it} in
\ccc{[start,end)}. \ccc{Point_dimension_d(p)} is also $D$.
 The points in range
\ccc{[start,end)} must be affinely independent, i.e., the simplex must
not be flat.}

\ccNestedType{In_flat_side_of_oriented_sphere_d}{A predicate object that must
provide the templated operator\\
\ccc{template<typename ForwardIterator>
Oriented_side operator()(Flat_orientation_d orient, ForwardIterator start, ForwardIterator end, const
Point_d & p)}.\\
The operator returns \ccc{ON_POSITIVE_SIDE},
\ccc{ON_NEGATIVE_SIDE} 
or \ccc{ON_ORIENTED_BOUNDARY}  depending of the side of the query
point \ccc{p}
 with respect to the sphere circumscribing the simplex
defined by the points in range \ccc{[start,end)}. 
If the simplex is positively
oriented according to \ccc{orient}, 
then the positive side of sphere corresponds geometrically
to its bounded side. 
The points in range \ccc{[start,end)} and \ccc{p} are supposed to belong to the lower dimensional flat
 whose orientation is given by \ccc{orient}.
\ccPrecond 
 \ccc{std::distance(start,end)=k+1} where $k$ is the number of
points used to construct \ccc{orient}.
\ccc{Point_dimension_d(*it)} is $D$ for all \ccc{it} in
\ccc{[start,end)}. \ccc{Point_dimension_d(p)} is also $D$.
 The points in range
\ccc{[start,end)} must be affinely independent, {i.e.,} the simplex must
not be flat.
}



%%%%%%%% currently unused
% \ccNestedType{Center_of_sphere_d}{A construction object that must
% provide the templated operator\\\ccc{template<typename ForwardIterator> bool
% operator()(ForwardIterator start, ForwardIterator end)}.\\The operator
% constructs the center of the sphere circumscribing the points in
% the range \ccc{R=[start, end)}. \ccPrecond The number of points in the range
% must be equal to one more than the dimension of the Euclidean space the points
% live in, {i.e.}, \ccc{std::distance(start,end)} is equal to \ccc{start->dimension()+1}.}


\ccCreation
\ccCreationVariable{traits}

\ccConstructor{DelaunayTriangulationTraits();}{The default constructor.}

\ccOperations
\ccThree{In_flat_side_of_oriented_sphere_d}{in_flat_side_of_oriented_sphere_d_object()
    const;}{}


The following methods permit access to the traits class's predicates:

\ccMethod{Side_of_oriented_sphere_d side_of_oriented_sphere_d_object() const;}
{}
\ccGlue
\ccMethod{In_flat_side_of_oriented_sphere_d in_flat_side_of_oriented_sphere_d_object()
const;}
{}


\ccHasModels

\ccc{CGAL::Cartesian_d<FT, Dim, LA>},\\
\ccc{CGAL::Simple_cartesian_d<FT, Dim, LA>},\\
\ccc{CGAL::New_kernel_d} (recommended when available)

\ccSeeAlso

\ccc{TriangulationTraits}\\
\ccc{DelaunayTriangulation}

\end{ccRefConcept}
